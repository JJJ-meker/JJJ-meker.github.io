<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Destin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-30T12:55:02.401Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Destin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈深度优先搜索dfs</title>
    <link href="http://yoursite.com/2020/04/29/%E6%B5%85%E8%B0%88%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2dfs/"/>
    <id>http://yoursite.com/2020/04/29/%E6%B5%85%E8%B0%88%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2dfs/</id>
    <published>2020-04-29T09:30:47.000Z</published>
    <updated>2020-04-30T12:55:02.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈深度优先搜索"><a href="#浅谈深度优先搜索" class="headerlink" title="浅谈深度优先搜索"></a>浅谈深度优先搜索</h1><h3 id="——Summary-of-April-1"><a href="#——Summary-of-April-1" class="headerlink" title="——Summary of April(1)"></a>——Summary of April(1)</h3><p>​        这段时间，工作室里安排了每周一题的算法题任务。一开始我只是单纯地去解决问题，后来遇到的问题我想直接解决已经有些困难了。其实说到底，也是因为自己的思维问题。所以，刷算法题还是很有必要的，同时，我也在读《算法 第四版》（推荐《算法导论》，但是建议不要一上来就看，有些难道，某些大佬除外）。</p><p>​        借由每周一题，我也开始看力扣上的算法题，这一方面，自己有所欠缺，所以要努力。好了，说说正题。简单谈一下DFS(Depth First Search)，深度优先搜索。</p><p>​        DFS是一种搜索方法，对于解决算法题是一种很直接”暴力“的方法。根据我的理解，DFS会将所有的方法都枚举出来，然后从中找出符合条件的方法。如果列出的方法不满足条件，就会回溯到上一个选择节点，做另一个选择。就像走迷宫一样，如果你要从迷宫走出去，你就要找到那条正确的路，你要决定你朝哪一个方向走。</p><p><img src="/2020/04/29/%E6%B5%85%E8%B0%88%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2dfs/%E6%B5%85%E8%B0%88%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2dfs%5C%E6%B5%85%E8%B0%88%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2dfs.jpg" alt="dfs"></p><p>​        DFS方法就是在走迷宫的时候，从起点出发，把每一条路都走一遍，当走的那一条<strong>走不出去时</strong>（限制条件），他就会折回来，走另一条路，直到<strong>走出去了</strong>（结束条件）之后才停下来。</p><p>​        假设你从起点出发，到了A，A下面有B、C、D三个方向，同时，B、C、D下还有其他的路，在只有一条路能走出去的情况下。DFS会从起点开始，一直往下走，并在走过的路上做一个标记。</p><p>​        假设没有走过的是<strong>0</strong>，走过后是<strong>1</strong>。一开始，所有都是0，从起点开始走：</p><p>​        A–&gt;B–&gt;E(出不去），然后回到B，将B和E的标志改为1。因为B下面还有一条路F没有走过，所有F还是0，于是走另一条路F，当它发现仍然出不去时，再次回到B，将F的标志也改成1。</p><p>​        此时发现 B下面的路已经走完了，所以得出从B走不出去的结论，然后回到上一级，也就是A。从A开始再次往下走，B已经走过置1，所以从C开始走，重复之前走B那一条路的过程。知道最后找到出口，结束搜索。</p><p>​        就拿我做的那道题来举例：</p><p><strong><em>题目来自力扣，岛屿个数问题，力扣连接：<a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands/</a></em></strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目：给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line">输出:<span class="number">3</span></span><br><span class="line">解释：没做岛屿只能由水平和/或竖直方向上相邻的陆地组成</span><br></pre></td></tr></table></figure><p>​        我们简单分析一下，给定这样的一个二维数组，我们要做的就是将所以岛屿找出来，即找出所以相连的1，也就是1的上下左右都是1的情况种数。于是我们可以得到一个初始，从第一个元素开始找，找到所有</p><p>符合条件的情况。</p><p>​        我们从第一个数开始遍历，一个岛屿是所有相连的1组成的，假设第一个是1，从第一个开始，往上下左右四个方向找，遇到0的时候就停下来，如果还是1，就从那个1开始再找。</p><p>​        你可能已经发现，这样会有很多重复的情况，而这会导致结果的偏差或者是程序执行的次数更多，更复杂。我们把1看做通过，0看做禁止。查找到的1，我们都让它变成0。直到最后四个方向都是0停止后，就找到了一个完整的岛。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfIsland</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    Search(grid,i,j);</span><br><span class="line">                    <span class="comment">//每查找完成一次就是一个岛</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">char</span>[][] list,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">//保证在网格内</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;list.length||j&lt;<span class="number">0</span>||j&gt;list[i].length)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是1就停止</span></span><br><span class="line">        <span class="keyword">if</span>(list[i][j]!=<span class="string">'1'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//置0</span></span><br><span class="line">        list[i][j]=<span class="string">'0'</span>;</span><br><span class="line">        Search(list, i+<span class="number">1</span>, j);</span><br><span class="line">        Search(list, i-<span class="number">1</span>, j);</span><br><span class="line">        Search(list, i, j+<span class="number">1</span>);</span><br><span class="line">        Search(list, i, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        我们通过将已经查找过的1置0的方式，来减少了查找的次数，从而减少了运行的时间，在使用DFS时也要注意重复和循环，减少不必要的重复，同时小心陷入循环而导致程序一直运行下去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈深度优先搜索&quot;&gt;&lt;a href=&quot;#浅谈深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;浅谈深度优先搜索&quot;&gt;&lt;/a&gt;浅谈深度优先搜索&lt;/h1&gt;&lt;h3 id=&quot;——Summary-of-April-1&quot;&gt;&lt;a href=&quot;#——Summary
      
    
    </summary>
    
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://yoursite.com/2020/03/23/my-first-blog/"/>
    <id>http://yoursite.com/2020/03/23/my-first-blog/</id>
    <published>2020-03-23T14:18:01.000Z</published>
    <updated>2020-04-29T06:59:38.861Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="my-first-blog"><a href="#my-first-blog" class="headerlink" title="my first blog"></a>my first blog</h1><p> 这是我的第一篇博客。作为一名计算机类的学生，在我大一开始之前，我对自己要做的事并不怎么了解。只是出于自己的兴趣，我选择了这个专业。后来，机缘巧合之下，我来到了南大家园。</p><p> 在这里呆了有快一年了，这一年里，我学到了许多。渐渐地，我了解到了很多我从未了解的新事物，感觉到知识的广阔，我要学的语言和技术有那么多。听学长说了之后，我也觉得，自己有写一些东西（写博客）的必要了。</p><p> 诚然，我自己的能力有限，学到的东西也就那么多。或许自己不是最优秀的，但是我在努力变得优秀。在家园里，每一次经历都是一次成长，每一次经历，都会在心里留下一个烙印。也许是喜悦，也许是难过……但是，每一次都铸就着现在的我。</p><p>我会在我的博客里写下一些自己的想法，和自己在学习过程中遇到的问题和一些知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;my-first-blog&quot;&gt;&lt;a href=&quot;#my-first-blog&quot; class=&quot;headerlink&quot; title=&quot;my first blog&quot;&gt;&lt;/a&gt;my first blog&lt;/h1&gt;&lt;p&gt; 这是我的第一篇博客。作为一名计算机类的学
      
    
    </summary>
    
    
    
      <category term="自我" scheme="http://yoursite.com/tags/%E8%87%AA%E6%88%91/"/>
    
  </entry>
  
</feed>
